<!doctype html>
<html lang="ca">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cartes Rockin</title>

<style>
  :root{
    --bg:#f6f7f9;
    --text:#222;
    --accent:#ffcc00;
    --panel:#ffffff;
    --border:rgba(0,0,0,.18);

    /* ESTRUCTURADA: mida compacta perquè càpiga tot sense scroll */
    --struct-card-h: 64px;     /* alçada del slot de carta (baixa-ho si cal) */
    --struct-gap: 6px;         /* espais dins la graella */
  }

  body{
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica;
    background:var(--bg);
    color:var(--text);
    margin:0;
    padding:16px;
  }

  h1{
    margin:0 0 10px 0;
    font-size:24px;
    font-weight:650;
    text-align:left;
  }

  .layout{
    display:grid;
    grid-template-columns: 360px 1fr;
    gap:14px;
    align-items:start;
  }
  @media (max-width: 980px){
    .layout{ grid-template-columns: 1fr; }
  }

  /* ===== LEFT ===== */
  .left{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:0 10px 24px rgba(0,0,0,.06);
    padding:12px;
  }

  .controls{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
    margin-bottom:10px;
  }

  select, button, input{
    font-size:14px;
    padding:10px 12px;
    border-radius:12px;
  }

  select{
    border:1px solid rgba(0,0,0,.18);
    background:white;
    flex: 1 1 160px;
  }

  button{
    background:var(--accent);
    border:none;
    font-weight:700;
    cursor:pointer;
  }

  .hint{
    font-size:12px;
    opacity:.65;
    margin: 10px 0 0 0;
    line-height:1.35;
  }

  /* ===== MAIN CARD ===== */
  .cardStage{
    width:100%;
    height: 420px;
    border-radius:16px;
    overflow:hidden;
    background:white;
    border:1px solid rgba(0,0,0,.10);
    box-shadow:0 10px 24px rgba(0,0,0,.10);
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
  }

  .cardStage.animate{
    animation: deal .38s cubic-bezier(.2,.9,.2,1);
  }

  @keyframes deal{
    0%{ transform:translateY(0); }
    35%{ transform:translateY(-10px); }
    70%{ transform:translateY(4px); }
    100%{ transform:translateY(0); }
  }

  .cardImg{
    width:100%;
    height:100%;
    object-fit:contain;
    background:white;
    user-select:none;
  }

  /* ===== RIGHT / BOARD ===== */
  .boardWrap{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:0 10px 24px rgba(0,0,0,.06);
    padding:12px;
  }

  .boardTop{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin: 0 0 10px 0;
  }

  .boardTopLeft{
    display:flex;
    align-items:center;
    gap:10px;
    flex-wrap:wrap;
  }

  .boardTitle{
    font-weight:650;
  }

  .zoomBar{
    display:flex;
    align-items:center;
    gap:6px;
    padding:4px 6px;
    border:1px solid rgba(0,0,0,.12);
    border-radius:12px;
    background:white;
  }

  .zoomBtn{
    background:#fff;
    border:1px solid rgba(0,0,0,.15);
    padding:6px 10px;
    border-radius:10px;
    font-weight:700;
    cursor:pointer;
  }

  .zoomPct{
    font-size:12px;
    opacity:.75;
    width:46px;
    text-align:center;
    font-variant-numeric: tabular-nums;
  }

  .modeSelect{
    border:1px solid rgba(0,0,0,.12);
    background:white;
    border-radius:12px;
    padding:8px 10px;
    font-size:13px;
  }

  .boardViewport{
    width:100%;
    height: 76vh;
    min-height: 520px;
    overflow:auto;
    border:2px dashed rgba(0,0,0,.20);
    border-radius:14px;
    background:white;
    position:relative;
  }

  .muted{
    font-size:12px;
    opacity:.65;
    margin-top:8px;
  }

  /* ===== FREE MODE CANVAS ===== */
  .freeCanvas{
    position:relative;
    width: 2600px;
    height: 1600px;
    transform-origin: 0 0;
    background:
      radial-gradient(circle at 1px 1px, rgba(0,0,0,.06) 1px, transparent 0) 0 0/24px 24px;
  }

  /* ===== Thumb (overlay draggable) ===== */
  .thumb{
    position:absolute;
    --w: 150px;
    width: var(--w);
    height:auto;
    border:none;
    background:transparent;
    box-shadow:none;
    cursor:grab;
    user-select:none;
    touch-action:none;
  }

  .thumb img{
    width:100%;
    height:auto;
    object-fit:contain;
    pointer-events:none;
    display:block;
  }

  .handle{
    position:absolute;
    right:-6px;
    bottom:-6px;
    width:14px;
    height:14px;
    border-radius:999px;
    background: rgba(0,0,0,.55);
    border: 2px solid rgba(255,255,255,.9);
    cursor: nwse-resize;
    touch-action:none;

    opacity:0;
    transform: scale(0.85);
    transition: opacity .12s ease, transform .12s ease;
    pointer-events:none;
  }

  .thumb:hover .handle,
  .thumb.is-active .handle{
    opacity:1;
    transform: scale(1);
    pointer-events:auto;
  }

  /* ===== STRUCTURED MODE (no scroll intended) ===== */
  .structuredWrap{
    transform-origin: 0 0;
    width: 100%;
    height: 100%;
    padding: 6px;
    box-sizing: border-box;
    position:relative;
  }

  .structuredTop{
    display:flex;
    align-items:center;
    gap:10px;
    margin-bottom:8px;
    flex-wrap:wrap;
  }

  .structuredTop label{
    font-size:12px;
    opacity:.85;
    display:flex;
    align-items:center;
    gap:8px;
  }

  .numInput{
    width:88px;
    border:1px solid rgba(0,0,0,.18);
    background:white;
    padding:7px 10px;
    border-radius:12px;
  }

  .miniBtn{
    background:#fff;
    border:1px solid rgba(0,0,0,.15);
    border-radius:12px;
    padding:7px 10px;
    cursor:pointer;
    font-weight:700;
    font-size:13px;
  }

  /* la graella que ha de cabre */
  .matrix{
    display:grid;
    gap: var(--struct-gap);
    align-items:stretch;
    width:100%;
  }

  .col{
    border:1px solid rgba(0,0,0,.10);
    border-radius:12px;
    background: rgba(255,255,255,.92);
    overflow:hidden;
    display:flex;
    flex-direction:column;
    min-width:0;
  }

  .colHeader{
    font-weight:650;
    font-size:11px;
    padding:6px 8px;
    border-bottom:1px solid rgba(0,0,0,.06);
    opacity:.85;
    background: rgba(0,0,0,.02);
  }

  .cell{
    border-bottom:1px dashed rgba(0,0,0,.08);
    padding:6px;
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .cell:last-child{ border-bottom:none; }

  .rowLabel{
    font-size:10px;
    opacity:.6;
    text-transform:uppercase;
    letter-spacing:.02em;
    line-height:1;
  }

  /* slot ultra compacte */
  .cardSlot{
    width:100%;
    height: var(--struct-card-h);
    border-radius:10px;
    background: rgba(0,0,0,.03);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
  }

  .cardSlot.empty{
    background: rgba(0,0,0,.015);
  }

  .cardSlot img{
    width:100%;
    height:100%;
    object-fit:contain;
    display:block;
  }

  /* capa base i overlay dins estructurada */
  .structuredBase{
    position:relative;
    z-index: 1; /* sempre a sota */
  }
  .structuredOverlay{
    position:absolute;
    inset: 0;
    z-index: 5; /* sempre a sobre */
    pointer-events:none; /* IMPORTANT: deixem que la base encara sigui usable */
  }
  /* però les thumbs de l’overlay han de rebre events */
  .structuredOverlay .thumb{
    pointer-events:auto;
  }

  .hidden{ display:none !important; }
</style>
</head>

<body>

<h1>Cartes Rockin</h1>

<div class="layout">

  <!-- LEFT -->
  <div class="left">
    <div class="controls">
      <select id="deck"></select>
      <button id="btnNew" type="button">Nova carta</button>
      <button id="btnClear" type="button">Neteja pissarra</button>
    </div>

    <div class="cardStage" id="cardStage">
      <img id="imgTop" class="cardImg" draggable="true" alt="Carta actual">
    </div>

    <p class="hint">
      <b>Enter</b> = nova carta · <b>Arrossega</b> la carta a la pissarra.
      A estructurada, la carta cau com a <b>overlay</b> per sobre de les cartes de creació.
    </p>
  </div>

  <!-- RIGHT -->
  <div class="boardWrap">

    <div class="boardTop">
      <div class="boardTopLeft">
        <div class="boardTitle">Pissarra</div>

        <select id="mode" class="modeSelect" aria-label="Mode pissarra">
          <option value="free">Pissarra lliure</option>
          <option value="structured">Pissarra estructurada</option>
        </select>

        <div class="zoomBar" aria-label="Zoom pissarra">
          <button class="zoomBtn" id="zoomOut" type="button">−</button>
          <div class="zoomPct" id="zoomPct">100%</div>
          <button class="zoomBtn" id="zoomIn" type="button">+</button>
        </div>
      </div>

      <div style="font-size:12px;opacity:.65;">scroll X/Y</div>
    </div>

    <div class="boardViewport" id="boardViewport">

      <!-- FREE -->
      <div class="freeCanvas" id="freeCanvas"></div>

      <!-- STRUCTURED -->
      <div class="structuredWrap hidden" id="structuredWrap">
        <div class="structuredTop">
          <label>
            <b>Columnes</b>
            <input id="colInput" class="numInput" type="number" min="1" max="10" value="5" />
          </label>

          <button class="miniBtn" id="btnProposal" type="button">Fes proposta aleatòria</button>

          <span style="font-size:12px;opacity:.65;">
            (mínim 1 carta per columna)
          </span>
        </div>

        <!-- BASE (creació) -->
        <div class="structuredBase">
          <div class="matrix" id="matrix"></div>
        </div>

        <!-- OVERLAY (altres cartes a sobre) -->
        <div class="structuredOverlay" id="structuredOverlay"></div>

        <div class="muted">
          Les cartes de creació queden a sota; qualsevol carta que arrosseguis queda a sobre.
          Doble clic a una carta overlay per eliminar-la.
        </div>
      </div>

    </div>

  </div>

</div>

<script>
/* ===== Config estructurada ===== */
const ROWS = [
  { key:"bateria",  label:"Bateria"  },
  { key:"teclat",   label:"Teclat"   },
  { key:"veu",      label:"Veu"      },
  { key:"baix",     label:"Baix"     },
  { key:"guitarra", label:"Guitarra" }
]

// probabilitat base (per fila) però assegurarem mínim 1 per columna
const PRESENCE_PROB = 0.55

/* ===== Estat ===== */
let MANIFEST = {}
let barallaActual = []
let barallaRestant = []
let currentPath = null

let zoom = 1.0
const ZOOM_MIN = 0.5
const ZOOM_MAX = 1.4
const ZOOM_STEP = 0.1

function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1))
    ;[a[i],a[j]]=[a[j],a[i]]
  }
  return a
}
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)) }

function normalizeKey(s){
  return (s || "")
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
}

function getMode(){
  return document.getElementById("mode").value
}

async function init(){
  MANIFEST = await (await fetch("manifest.json")).json()

  // deck selector
  const select = document.getElementById("deck")
  Object.keys(MANIFEST).forEach(b=>{
    const opt=document.createElement("option")
    opt.value=b
    opt.textContent=b
    select.appendChild(opt)
  })
  select.addEventListener("change", carregarBaralla)

  document.getElementById("btnNew").addEventListener("click", novaCarta)
  document.getElementById("btnClear").addEventListener("click", clearBoard)
  document.getElementById("mode").addEventListener("change", applyMode)

  document.addEventListener("keydown", e=>{
    if(e.key==="Enter") novaCarta()
  })

  // zoom
  document.getElementById("zoomIn").addEventListener("click", ()=> setZoom(zoom + ZOOM_STEP))
  document.getElementById("zoomOut").addEventListener("click", ()=> setZoom(zoom - ZOOM_STEP))
  updateZoomUI()

  // structured proposal
  document.getElementById("btnProposal").addEventListener("click", buildProposal)

  // drag from main -> depending on mode
  const imgTop = document.getElementById("imgTop")
  imgTop.addEventListener("dragstart", (e)=>{
    if(!currentPath) return
    e.dataTransfer.setData("text/plain", currentPath)
    e.dataTransfer.effectAllowed="copy"
  })

  // drop targets
  const freeCanvas = document.getElementById("freeCanvas")
  freeCanvas.addEventListener("dragover", e=>e.preventDefault())
  freeCanvas.addEventListener("drop", e=>{
    e.preventDefault()
    if(getMode()!=="free") return
    const path = e.dataTransfer.getData("text/plain")
    if(!path) return
    const rect = freeCanvas.getBoundingClientRect()
    const x = (e.clientX - rect.left) / zoom
    const y = (e.clientY - rect.top) / zoom
    addThumbToFree(path, x, y)
  })

  const overlay = document.getElementById("structuredOverlay")
  overlay.addEventListener("dragover", e=>e.preventDefault())
  overlay.addEventListener("drop", e=>{
    e.preventDefault()
    if(getMode()!=="structured") return
    const path = e.dataTransfer.getData("text/plain")
    if(!path) return

    // coordenades relatives al structuredWrap (no al viewport)
    const wrap = document.getElementById("structuredWrap")
    const rect = wrap.getBoundingClientRect()
    const x = (e.clientX - rect.left) / zoom
    const y = (e.clientY - rect.top) / zoom

    addThumbToStructuredOverlay(path, x, y)
  })

  // input columnes: reconstruïm proposta quan canviï (opcional)
  document.getElementById("colInput").addEventListener("change", ()=>{
    // no fem proposta automàtica; només preparem i deixem el botó
    // però si vols que regeneri al canvi, descomenta:
    // buildProposal()
  })

  carregarBaralla()
  setZoom(1.0)
  applyMode()
  buildProposal()
}

function setZoom(z){
  zoom = clamp(z, ZOOM_MIN, ZOOM_MAX)
  updateZoomUI()

  if(getMode()==="free"){
    document.getElementById("freeCanvas").style.transform = `scale(${zoom})`
  }else{
    document.getElementById("structuredWrap").style.transform = `scale(${zoom})`
  }
}

function updateZoomUI(){
  document.getElementById("zoomPct").textContent = Math.round(zoom*100) + "%"
}

function applyMode(){
  const mode = getMode()
  const freeCanvas = document.getElementById("freeCanvas")
  const structured = document.getElementById("structuredWrap")

  if(mode==="free"){
    structured.classList.add("hidden")
    freeCanvas.classList.remove("hidden")
    freeCanvas.style.transformOrigin="0 0"
    freeCanvas.style.transform = `scale(${zoom})`
  }else{
    freeCanvas.classList.add("hidden")
    structured.classList.remove("hidden")
    structured.style.transformOrigin="0 0"
    structured.style.transform = `scale(${zoom})`
  }
}

/* ===== Carta gran ===== */
function carregarBaralla(){
  const deck = document.getElementById("deck").value
  barallaActual = [...MANIFEST[deck]]
  barallaRestant = shuffle([...barallaActual])
  novaCarta()
}

function setMainImg(path){
  const img=document.getElementById("imgTop")
  const url=new URL(path, window.location.href)
  url.searchParams.set("t", Date.now())
  img.src=url.toString()
}

function novaCarta(){
  if(barallaRestant.length===0) barallaRestant = shuffle([...barallaActual])
  currentPath = barallaRestant.pop()
  setMainImg(currentPath)

  const stage=document.getElementById("cardStage")
  stage.classList.remove("animate")
  void stage.offsetWidth
  stage.classList.add("animate")
}

/* ===== Free board thumbs ===== */
function addThumbToFree(path, x, y){
  const canvas=document.getElementById("freeCanvas")
  const t = createThumb(path)
  t.style.left=(x-75)+"px"
  t.style.top=(y-90)+"px"
  makeMovable(t, canvas, () => zoom)
  canvas.appendChild(t)
}

/* ===== Structured overlay thumbs ===== */
function addThumbToStructuredOverlay(path, x, y){
  const overlay=document.getElementById("structuredOverlay")
  const t = createThumb(path)

  // una mica més petita per defecte, perquè no tapi massa
  t.style.setProperty("--w","140px")

  t.style.left=(x-70)+"px"
  t.style.top=(y-80)+"px"

  makeMovable(t, overlay, () => zoom)
  overlay.appendChild(t)
}

function createThumb(path){
  const t=document.createElement("div")
  t.className="thumb"
  t.style.setProperty("--w","150px")

  const img=document.createElement("img")
  const url=new URL(path, window.location.href)
  url.searchParams.set("t", Date.now())
  img.src=url.toString()

  const handle=document.createElement("div")
  handle.className="handle"
  handle.title="Arrossega per canviar la mida"

  t.appendChild(img)
  t.appendChild(handle)

  // eliminar
  t.addEventListener("dblclick", ()=>t.remove())

  makeResizable(t, handle, () => zoom)
  return t
}

function makeMovable(el, container, getZoom){
  let startX=0,startY=0,origL=0,origT=0,dragging=false

  el.addEventListener("pointerdown",(e)=>{
    if(e.target && e.target.classList.contains("handle")) return
    dragging=true
    el.classList.add("is-active")
    el.setPointerCapture(e.pointerId)
    el.style.zIndex=String(Date.now())

    startX=e.clientX; startY=e.clientY
    origL=parseFloat(el.style.left||"0")
    origT=parseFloat(el.style.top||"0")
  })

  el.addEventListener("pointermove",(e)=>{
    if(!dragging) return
    const z = getZoom()
    const dx=(e.clientX-startX)/z
    const dy=(e.clientY-startY)/z

    const containerW = container.clientWidth
    const containerH = container.clientHeight

    const w = el.getBoundingClientRect().width / z
    const h = el.getBoundingClientRect().height / z

    let newL=origL+dx
    let newT=origT+dy

    newL=clamp(newL,0,containerW-w)
    newT=clamp(newT,0,containerH-h)

    el.style.left=newL+"px"
    el.style.top=newT+"px"
  })

  el.addEventListener("pointerup",(e)=>{
    dragging=false
    el.classList.remove("is-active")
    try{el.releasePointerCapture(e.pointerId)}catch(_){}
  })
  el.addEventListener("pointercancel",()=>{
    dragging=false
    el.classList.remove("is-active")
  })
}

function makeResizable(el, handle, getZoom){
  let startX=0,startW=150,resizing=false

  handle.addEventListener("pointerdown",(e)=>{
    resizing=true
    el.classList.add("is-active")
    handle.setPointerCapture(e.pointerId)
    el.style.zIndex=String(Date.now())
    startX=e.clientX
    startW=parseFloat(getComputedStyle(el).getPropertyValue("--w"))||150
    e.preventDefault(); e.stopPropagation()
  })

  handle.addEventListener("pointermove",(e)=>{
    if(!resizing) return
    const z = getZoom()
    const dx=(e.clientX-startX)/z
    const newW=clamp(startW+dx,60,520)
    el.style.setProperty("--w",newW+"px")
  })

  handle.addEventListener("pointerup",(e)=>{
    resizing=false
    el.classList.remove("is-active")
    try{handle.releasePointerCapture(e.pointerId)}catch(_){}
  })
  handle.addEventListener("pointercancel",()=>{
    resizing=false
    el.classList.remove("is-active")
  })
}

/* ===== Structured proposal logic ===== */
function findCreationDeckKey(){
  const keys = Object.keys(MANIFEST)
  return keys.find(k => normalizeKey(k).includes("creacio")) || null
}

function buildCreationCardMap(){
  const key = findCreationDeckKey()
  if(!key) return { _error: "No trobo cap baralla amb 'Creacio/Creació' al manifest." }

  const list = MANIFEST[key] || []
  const normList = list.map(p => ({ path:p, norm: normalizeKey(p) }))

  const map = {}
  for(const row of ROWS){
    const hit = normList.find(o => o.norm.includes(row.key))
    if(hit) map[row.key] = hit.path
  }

  const foundCount = Object.keys(map).length
  if(foundCount === 0){
    return { _error: `He trobat la baralla "${key}", però no identifico els fitxers per bateria/teclat/veu/baix/guitarra al nom de fitxer.` }
  }
  return map
}

function buildProposal(){
  const colInput = document.getElementById("colInput")
  let cols = Number(colInput.value || 5)
  cols = clamp(cols, 1, 10)
  colInput.value = cols

  const matrix = document.getElementById("matrix")
  matrix.innerHTML = ""
  matrix.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`

  const cardMap = buildCreationCardMap()

  if(cardMap._error){
    const col = document.createElement("div")
    col.className = "col"
    col.innerHTML = `
      <div class="colHeader">⚠️ Problema amb “Creació”</div>
      <div style="padding:10px;font-size:12px;opacity:.75;line-height:1.4">
        ${escapeHtml(cardMap._error)}
      </div>
    `
    matrix.appendChild(col)
    return
  }

  for(let c=0;c<cols;c++){
    const col = document.createElement("div")
    col.className = "col"

    const header = document.createElement("div")
    header.className = "colHeader"
    header.textContent = `Proposta ${c+1}`
    col.appendChild(header)

    // decidim quines files surten (amb mínim 1)
    let chosen = []
    for(let r=0;r<ROWS.length;r++){
      if(Math.random() < PRESENCE_PROB) chosen.push(r)
    }
    if(chosen.length === 0){
      chosen = [Math.floor(Math.random()*ROWS.length)]
    }

    for(let r=0;r<ROWS.length;r++){
      const row = ROWS[r]
      const cell = document.createElement("div")
      cell.className = "cell"

      const label = document.createElement("div")
      label.className = "rowLabel"
      label.textContent = row.label

      const slot = document.createElement("div")
      slot.className = "cardSlot"

      const path = cardMap[row.key]
      const show = chosen.includes(r) && !!path

      if(show){
        const img = document.createElement("img")
        const url = new URL(path, window.location.href)
        url.searchParams.set("t", Date.now())
        img.src = url.toString()
        img.alt = row.label
        slot.appendChild(img)
      }else{
        slot.classList.add("empty")
      }

      cell.appendChild(label)
      cell.appendChild(slot)
      col.appendChild(cell)
    }

    matrix.appendChild(col)
  }
}

function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;")
}

/* ===== Clear ===== */
function clearBoard(){
  if(getMode()==="free"){
    document.getElementById("freeCanvas").innerHTML = ""
  }else{
    // buida només la proposta base, i també l’overlay
    document.getElementById("matrix").innerHTML = ""
    document.getElementById("structuredOverlay").innerHTML = ""
  }
}

init()
</script>

</body>
</html>